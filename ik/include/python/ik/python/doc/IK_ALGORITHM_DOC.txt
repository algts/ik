Algorithm objects define solver parameters such as the solver type, tolerance,
and maximum number of iterations to use.  Some  of  these  parameters  can  be
changed at any time without having to  rebuild  the solver (max_iterations and
tolerance), while others require  you  to  rebuild the solver before they take
effect.
 
Each  end effector will try to select an algorithm attached to the end of  the
chain (known as the "base node"). If there is no algorithm on the base node of
a chain, then it searches  upwards  (towards  the  root  node)  for  the  next
attached algorithm.  This  makes  it possible to attach multiple algorithms at
different  locations in the tree and have  them  selected  based  on  the  end
effector's chain length parameter.
 
For example:
                        ____               ____
                       |        n4 <- e1       |
                       |        |              | a1 is selected if
    a2 is selected if  |        n3             | e1->chain_length=2
    e1->chain_length=3 |        |              |
                       |        n2 <- a1   ____|
                       |        |
                       |____    n1 <- a2
 
    >>> e1 = n4.effector = ik.Effector()
    >>> a1 = n2.algorithm = ik.Algorithm(ik.TWO_BONE)
    >>> a2 = n1.algorithm = ik.Algorithm(ik.FABRIK)
    >>> s = ik.Solver(n1)
 
Notice that all algorithms deeper than the  chain's base node are ignored. The
following example will print an error:
  
                                n4 <- e1 
                                |        
                                n3       
                                |        
                                n2 <- a1 
                                |
                                n1
 
    >>> e1 = n4.effector = ik.Effector()
    >>> a1 = n2.algorithm = ik.Algorithm(ik.FABRIK)
    >>> s = ik.Solver(n1)
 
This causes an error because the end effector has specified a chain  length of
0, so the  solver  is looking for an algorithm in n1 (or a parent thereof) and
can't find any. The solution is to set  the  chain  length  to  either 1 or 2:
n4.effector = ik.Effector(chain_length=2)
 
It  is  also  possible to change algorithms partway down the tree by attaching
another end effector:
 
                              n4
                      ____    Â¦
                     |        n3 <- e2
    This section is  |        |
    solved by the    |        n2
    TWO_BONE solver  |        |              ____
                     |____    n1 <- e1, a2       | This section is
                              |                  | solved by the
                              n0 <- a1       ____| ONE_BONE solver
 
    >>> a1 = n0.algorithm = ik.Algorithm(ik.ONE_BONE)
    >>> a2 = n1.algorithm = ik.Algorithm(ik.TWO_BONE)
    >>> e1 = n1.effector = ik.Effector()
    >>> e2 = n3.effector = ik.Effector()
 
If the a2 algorithm were not attached, then  both  chains created by e1 and e2
would select algorithm a1.
 
All properties can be specified in the constructor. The only required argument
is the algorithm type:
 
    >>> import ik
    >>> ik.Algorithm(type=ik.FABRIK, 
    ...              max_iterations=20,
    ...              tolerance=1e-2,
    ...              constraints=True,
    ...              poles=True,
    ...              target_rotations=True,
    ...              integrate_rk45=True)
 
The available algorithm types are:
  - ik.ONE_BONE
  - ik.TWO_BONE
  - ik.FABRIK
  - ik.MSS
