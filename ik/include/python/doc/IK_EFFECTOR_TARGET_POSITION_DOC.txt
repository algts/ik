A  ik.Vec3()  specifying  the goal the node this end-effector is  attached  to
should try and reach.
 
The  position is in the same space as the solver's root node (not a  child  of
the solver's root node, but a child of the parent of the  solver's  root node,
i.e. "solver  global space"). If the solver's root node has a parent, then you
will have to make  sure to transform the target position and rotation into the
correct space  before  calling  solver.solve(). To illustrate what this means,
consider the following example:
 
              n3 <- e1
              |
              n2
              |
              n1 <- a1
              |
              n0
 
    >>> n0 = ik.Node()
    >>> n1 = n0.create_child()
    >>> n2 = n1.create_child()
    >>> n3 = n2.create_child()
    >>> n3.effector = ik.Effector()
    >>> n1.algorithm = ik.Algorithm(ik.TWO_BONE)
    >>> s = ik.Solver(n1)
 
Notice how the solver was created on node n1 and NOT node n0. This  means that
e1's  target  position  is not in our  global  space,  but  relative  to  n0's
transform. The solver sees n1 as the root node instead of n0.
 
Therefore, if  we  set  the  target  position  in  our  global  space, we must
transform  it  into  the  space  of  n0  before  solving.   We   can  use  the
global_transform property of a node to achieve this:
 
    >>> e1.target_position =
            s.root.parent.global_transform * get_global_target_position()
 
Where  get_global_target_position()  returns  a  ik.Vec3()  position in global
space.
 
If performance is a  concern, cache the return value of node.global_transform.
Every access  of  this  property  causes  the  4x3  matrix to be recalculated.
